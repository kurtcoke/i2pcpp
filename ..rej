--- Database.cpp
+++ Database.cpp
@@ -191,7 +191,7 @@
 
     RouterInfo Database::getRouterInfo(std::string const &routerHash)
     {
-        return getRouterInfo(Base64::decode(routerHash));
+        return getRouterInfo(toRouterHash(Base64::decode(routerHash)));
     }
 
     RouterInfo Database::getRouterInfo(RouterHash const &routerHash)
@@ -241,7 +241,7 @@
 
                 sqlite3_finalize(statement);
             } else
-                throw RecordNotFound(routerHash);
+                throw RecordNotFound(Base64::encode(routerHash));
 
             Mapping router_options;
 
--- InboundMessageDispatcher.cpp
+++ InboundMessageDispatcher.cpp
@@ -95,7 +95,7 @@
             Mapping am;
             am.setValue("caps", "BC");
             am.setValue("host", m_ctx.getDatabase().getConfigValue("ssu_external_ip"));
-            am.setValue("key", m_ctx.getIdentity()->getHash());
+            am.setValue("key", Base64::encode(m_ctx.getIdentity()->getHash()));
             am.setValue("port", m_ctx.getDatabase().getConfigValue("ssu_external_port"));
             RouterAddress a(5, Date(0), "SSU", am);
 
--- Router.cpp
+++ Router.cpp
@@ -73,7 +73,7 @@
         Mapping am;
         am.setValue("caps", "BC");
         am.setValue("host", m_ctx.getDatabase().getConfigValue("ssu_external_ip"));
-        am.setValue("key", m_ctx.getIdentity()->getHash());
+        am.setValue("key", Base64::encode(m_ctx.getIdentity()->getHash()));
         am.setValue("port", m_ctx.getDatabase().getConfigValue("ssu_external_port"));
         RouterAddress a(5, Date(0), "SSU", am);
 
--- BuildRecord.cpp
+++ BuildRecord.cpp
@@ -51,7 +51,7 @@
         Botan::DL_Group group("modp/ietf/2048");
         Botan::ElGamal_PublicKey elgKey(group, Botan::BigInt(encryptionKey.data(), encryptionKey.size()));
         Botan::PK_Encryptor *pke = new Botan::PK_Encryptor_EME(elgKey, "Raw");
-        m_data = pke->encrypt(toEncrypt, rng);
+        m_data = toStaticByteArray<512>(pke->encrypt(toEncrypt, rng));
     }
 
     void BuildRecord::decrypt(std::shared_ptr<const Botan::ElGamal_PrivateKey> key)
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -8,8 +8,10 @@
     Endpoint.cpp
     Mapping.cpp
     RouterAddress.cpp
+    RouterHash.cpp
     RouterIdentity.cpp
     RouterInfo.cpp
+    SessionKey.cpp
 )
 
 add_library(datatypes STATIC ${datatypes_sources})
--- Endpoint.h
+++ Endpoint.h
@@ -66,21 +66,19 @@
 namespace std {
     template<>
     struct hash<i2pcpp::Endpoint> {
-        public:
-            size_t operator()(const i2pcpp::Endpoint &ep) const
-            {
-                hash<string> f;
-                return f(ep);
-            }
+        size_t operator()(const i2pcpp::Endpoint &ep) const
+        {
+            hash<string> f;
+            return f(ep);
+        }
     };
 
     template<>
     struct equal_to<i2pcpp::Endpoint> {
-        public:
-            bool operator()(const i2pcpp::Endpoint& lhs, const i2pcpp::Endpoint& rhs) const
-            {
-                return lhs == rhs;
-            }
+        bool operator()(const i2pcpp::Endpoint& lhs, const i2pcpp::Endpoint& rhs) const
+        {
+            return lhs == rhs;
+        }
     };
 }
 
--- RouterHash.cpp
+++ RouterHash.cpp
@@ -0,0 +1,8 @@
+#include "RouterHash.h"
+
+namespace i2pcpp {
+    RouterHash toRouterHash(ByteArray const &b)
+    {
+        return toStaticByteArray<32>(b);
+    }
+}
--- RouterHash.h
+++ RouterHash.h
@@ -9,6 +9,8 @@
 
 namespace i2pcpp {
     typedef StaticByteArray<32> RouterHash;
+
+    RouterHash toRouterHash(ByteArray const &b);
 }
 
 #endif
--- SessionKey.cpp
+++ SessionKey.cpp
@@ -0,0 +1,8 @@
+#include "SessionKey.h"
+
+namespace i2pcpp {
+    SessionKey toSessionKey(ByteArray const &b)
+    {
+        return toStaticByteArray<32>(b);
+    }
+}
--- SessionKey.h
+++ SessionKey.h
@@ -9,6 +9,8 @@
 
 namespace i2pcpp {
     typedef StaticByteArray<32> SessionKey;
+
+    SessionKey toSessionKey(ByteArray const &b);
 }
 
 #endif
--- StaticByteArray.h
+++ StaticByteArray.h
@@ -1,111 +1,52 @@
-/**
- * @file StaticByteArray.h
- * @brief Defines the i2pcpp::StaticByteArray type, which is an utility type.
- */
 #ifndef STATICBYTEARRAY_H
 #define STATICBYTEARRAY_H
 
-#include <algorithm>
 #include <array>
-#include <string>
-#include <functional>
 #include <iostream>
-#include <sstream>
-#include <iomanip>
-
-#include "../util/Base64.h"
 
 #include "ByteArray.h"
+#include "../util/Base64.h"
 
 namespace i2pcpp {
-    /**
-     * Provides a std::array with additional utility functions.
-     */
     template<std::size_t L>
-    struct StaticByteArray : public std::array<unsigned char, L> {
-        StaticByteArray() = default;
-
-        /**
-         * Clears the underlying data.
-         */
-        ~StaticByteArray()
-        {
-            this->fill(0);
-        }
-
-        /**
-         * Constructs from an i2pcpp::ByteArray.
-         */
-        StaticByteArray(ByteArray const &b)
-        {
-            if(b.size() < L)
-                std::copy(b.cbegin(), b.cend(), this->begin());
-            else
-                std::copy(b.cbegin(), b.cbegin() + L, this->begin());
-        }
-
-        /**
-         * Constructs from a base64-encoded std::string.
-         * @throw std::runtime_error if the input string is not of the correct size
-         */
-        StaticByteArray(std::string const &s)
-        {
-            ByteArray b = Base64::decode(s);
-            if(b.size() != L)
-                throw std::runtime_error("input string not correct size for StaticByteArray");
-            std::copy(b.cbegin(), b.cbegin() + L, this->begin());
-        }
-
-        /**
-         * @return a hexadecimal string representing the underlying data
-         */
-        std::string toHex() const
-        {
-            std::stringstream s;
-            for(const auto& c: *this)
-                s << std::setw(2) << std::setfill('0') << std::hex << (int)c;
-
-            return s.str();
-        }
+    using StaticByteArray = std::array<unsigned char, L>;
 
-        /**
-         * Conversion to an i2pcpp::ByteArray.
-         */
-        operator ByteArray() const
-        {
-            return ByteArray(this->cbegin(), this->cend());
-        }
+    template<std::size_t L>
+    StaticByteArray<L> toStaticByteArray(ByteArray const &b)
+    {
+        StaticByteArray<L> ret;
 
-        /**
-         * Converts to a std::string, by using base64 encoding.
-         */
-        operator std::string() const
-        {
-            std::string b64 = Base64::encode(ByteArray(this->begin(), this->cend()));
-            std::replace(b64.begin(), b64.end(), '+', '-');
-            std::replace(b64.begin(), b64.end(), '/', '~');
+        if(b.size() < L)
+            std::copy(b.cbegin(), b.cend(), ret.begin());
+        else
+            std::copy(b.cbegin(), b.cbegin() + L, ret.begin());
 
-            return b64;
-        }
-    };
+        return ret;
+    }
 
     template<std::size_t L>
-    std::ostream& operator<<(std::ostream &s, StaticByteArray<L> const &sba)
+    ByteArray toByteArray(StaticByteArray<L> const &sba)
     {
-        s << std::string(sba);
-        return s;
+        return ByteArray(sba.cbegin(), sba.cend());
     }
 }
 
 namespace std {
-    template<size_t L>
+    template<std::size_t L>
     struct hash<i2pcpp::StaticByteArray<L>> {
-        public:
         size_t operator()(const i2pcpp::StaticByteArray<L> &sba) const
         {
             hash<string> f;
-            return f(sba);
+            return f(std::string(sba.cbegin(), sba.cend()));
         }
     };
+
+    template<std::size_t L>
+    std::ostream& operator<<(std::ostream &s, i2pcpp::StaticByteArray<L> const &sba)
+    {
+        s << i2pcpp::Base64::encode(sba);
+        return s;
+    }
 }
+
 #endif
--- Kademlia.cpp
+++ Kademlia.cpp
@@ -90,6 +90,6 @@
     std::size_t hash_value(DHT::Kademlia::key_type const &k)
     {
         boost::hash<std::string> f;
-        return f(k);
+        return f(std::string(k.cbegin(), k.cend()));
     }
 }
--- TODO
+++ TODO
@@ -14,3 +14,4 @@
 Write CMake modules to find the various libraries.
 If tests are available, run them after building (make it an option).
 Investigate whether the Version.cpp/.h system should be modified.
+Investigate whether or not Database can be templatized.
--- DeliveryStatus.cpp
+++ DeliveryStatus.cpp
@@ -22,7 +22,7 @@
             Mapping am;
             am.setValue("caps", "BC");
             am.setValue("host", m_ctx.getDatabase().getConfigValue("ssu_external_ip"));
-            am.setValue("key", m_ctx.getIdentity()->getHash());
+            am.setValue("key", Base64::encode(m_ctx.getIdentity()->getHash()));
             am.setValue("port", m_ctx.getDatabase().getConfigValue("ssu_external_port"));
             RouterAddress a(5, Date(0), "SSU", am);
 
--- TunnelData.cpp
+++ TunnelData.cpp
@@ -2,11 +2,9 @@
 
 namespace i2pcpp {
     namespace I2NP {
-        TunnelData::TunnelData(uint32_t const tunnelId, ByteArray const &data) :
-            m_tunnelId(tunnelId)
-        {
-            std::copy(data.cbegin(), data.cbegin() + 1024, m_data.begin());
-        }
+        TunnelData::TunnelData(uint32_t const tunnelId, StaticByteArray<1024> const &data) :
+            m_tunnelId(tunnelId),
+            m_data(data) {}
 
         uint32_t TunnelData::getTunnelId() const
         {
--- TunnelData.h
+++ TunnelData.h
@@ -9,7 +9,7 @@
     namespace I2NP {
         class TunnelData : public Message {
             public:
-                TunnelData(uint32_t const tunnelId, ByteArray const &data);
+                TunnelData(uint32_t const tunnelId, StaticByteArray<1024> const &data);
 
                 uint32_t getTunnelId() const;
                 const StaticByteArray<1024>& getData() const;
--- UDPTransport.cpp
+++ UDPTransport.cpp
@@ -11,7 +11,7 @@
         Transport(),
         m_socket(m_ios),
         m_peers(*this),
-        m_packetHandler(*this, (SessionKey)(ByteArray)ri.getHash()),
+        m_packetHandler(*this, ri.getHash()),
         m_establishmentManager(*this, privKey, ri),
         m_ackManager(*this),
         m_omf(*this),
--- EstablishmentManager.cpp
+++ EstablishmentManager.cpp
@@ -158,7 +158,7 @@
             p->encrypt(state->getIV(), state->getSessionKey(), state->getMacKey());
 
             const ByteArray& dhSecret = state->getDHSecret();
-            SessionKey newKey(dhSecret), newMacKey;
+            SessionKey newKey(toSessionKey(dhSecret)), newMacKey;
 
             state->setSessionKey(newKey);
 
@@ -182,7 +182,7 @@
             }
 
             const ByteArray& dhSecret = state->getDHSecret();
-            SessionKey newKey(dhSecret), newMacKey;
+            SessionKey newKey(toSessionKey(dhSecret)), newMacKey;
 
             state->setSessionKey(newKey);
 
--- EstablishmentState.cpp
+++ EstablishmentState.cpp
@@ -11,7 +11,7 @@
             m_direction(EstablishmentState::Direction::INBOUND),
             m_dsaKey(dsaKey),
             m_myIdentity(myIdentity),
-            m_sessionKey((ByteArray)myIdentity.getHash()),
+            m_sessionKey(myIdentity.getHash()),
             m_macKey(m_sessionKey),
             m_theirEndpoint(ep)
         {
@@ -25,7 +25,7 @@
             m_direction(EstablishmentState::Direction::OUTBOUND),
             m_dsaKey(dsaKey),
             m_myIdentity(myIdentity),
-            m_sessionKey((ByteArray)theirIdentity.getHash()),
+            m_sessionKey(theirIdentity.getHash()),
             m_macKey(m_sessionKey),
             m_theirEndpoint(ep),
             m_theirIdentity(std::make_shared<RouterIdentity>(theirIdentity))
--- Message.cpp
+++ Message.cpp
@@ -38,7 +38,7 @@
         if(!verifyChecksum())
             throw std::runtime_error("invalid checksum in tunnel message");
 
-        ByteArray data = m_encrypted;
+        ByteArray data = toByteArray(m_encrypted);
         auto pos = data.cbegin() + 4;
         auto end = data.cend();
 
--- Base64.cpp
+++ Base64.cpp
@@ -1,92 +1,93 @@
 #include "Base64.h"
 
 namespace i2pcpp {
-    const std::string Base64::b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~";
+    namespace Base64 {
+        static const std::string b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~";
 
-    inline bool Base64::is_base64(unsigned char c) {
-        return (isalnum(c) || (c == '-') || (c == '~'));
-    }
+        inline bool is_base64(unsigned char c) {
+            return (isalnum(c) || (c == '-') || (c == '~'));
+        }
 
-    std::string Base64::encode(ByteArray const &b) {
-        std::string ret;
-        int h = 0, i = 0, j = 0;
-        size_t length = b.size();
-        unsigned char char_array_3[3];
-        unsigned char char_array_4[4];
+        std::string encode(unsigned char *data, size_t length) {
+            std::string ret;
+            int h = 0, i = 0, j = 0;
+            unsigned char char_array_3[3];
+            unsigned char char_array_4[4];
+
+            while (length--) {
+                char_array_3[i++] = data[h++];
+                if (i == 3) {
+                    char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+                    char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+                    char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+                    char_array_4[3] = char_array_3[2] & 0x3f;
+
+                    for(i = 0; (i < 4) ; i++)
+                        ret += b64chars[char_array_4[i]];
+                    i = 0;
+                }
+            }
+
+            if (i)
+            {
+                for(j = i; j < 3; j++)
+                    char_array_3[j] = '\0';
 
-        while (length--) {
-            char_array_3[i++] = b[h++];
-            if (i == 3) {
                 char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
                 char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
                 char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
                 char_array_4[3] = char_array_3[2] & 0x3f;
 
-                for(i = 0; (i < 4) ; i++)
-                    ret += b64chars[char_array_4[i]];
-                i = 0;
-            }
-        }
-
-        if (i)
-        {
-            for(j = i; j < 3; j++)
-                char_array_3[j] = '\0';
-
-            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
-            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
-            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
-            char_array_4[3] = char_array_3[2] & 0x3f;
+                for (j = 0; (j < i + 1); j++)
+                    ret += b64chars[char_array_4[j]];
 
-            for (j = 0; (j < i + 1); j++)
-                ret += b64chars[char_array_4[j]];
+                while((i++ < 3))
+                    ret += '=';
 
-            while((i++ < 3))
-                ret += '=';
+            }
 
+            return ret;
         }
 
-        return ret;
-    }
+        ByteArray decode(std::string const &s)
+        {
+            size_t in_len = s.size();
+            size_t i = 0, j = 0;
+            int in_ = 0;
+            unsigned char char_array_4[4], char_array_3[3];
+            ByteArray ret;
+
+            while (in_len-- && ( s[in_] != '=') && is_base64(s[in_])) {
+                char_array_4[i++] = s[in_]; in_++;
+                if (i ==4) {
+                    for (i = 0; i <4; i++)
+                        char_array_4[i] = static_cast<unsigned char>(b64chars.find(char_array_4[i]));
+
+                    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+                    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+                    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+                    for (i = 0; (i < 3); i++)
+                        ret.push_back(char_array_3[i]);
+                    i = 0;
+                }
+            }
 
-    ByteArray Base64::decode(std::string const &s)
-    {
-        size_t in_len = s.size();
-        size_t i = 0, j = 0;
-        int in_ = 0;
-        unsigned char char_array_4[4], char_array_3[3];
-        ByteArray ret;
+            if (i) {
+                for (j = i; j <4; j++)
+                    char_array_4[j] = 0;
 
-        while (in_len-- && ( s[in_] != '=') && is_base64(s[in_])) {
-            char_array_4[i++] = s[in_]; in_++;
-            if (i ==4) {
-                for (i = 0; i <4; i++)
-                    char_array_4[i] = static_cast<unsigned char>(b64chars.find(char_array_4[i]));
+                for (j = 0; j <4; j++)
+                    char_array_4[j] = static_cast<unsigned char>(b64chars.find(char_array_4[j]));
 
                 char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
                 char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
                 char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
 
-                for (i = 0; (i < 3); i++)
-                    ret.push_back(char_array_3[i]);
-                i = 0;
+                for (j = 0; (j < i - 1); j++) ret.push_back(char_array_3[j]);
             }
-        }
 
-        if (i) {
-            for (j = i; j <4; j++)
-                char_array_4[j] = 0;
-
-            for (j = 0; j <4; j++)
-                char_array_4[j] = static_cast<unsigned char>(b64chars.find(char_array_4[j]));
-
-            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
-            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
-            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
-
-            for (j = 0; (j < i - 1); j++) ret.push_back(char_array_3[j]);
+            return ret;
         }
-
-        return ret;
     }
 }
--- Base64.h
+++ Base64.h
@@ -6,16 +6,18 @@
 #include "../datatypes/ByteArray.h"
 
 namespace i2pcpp {
+    namespace Base64 {
+        ByteArray decode(std::string const &s);
 
-    class Base64 {
-        public:
-            static ByteArray decode(std::string const &s);
-            static std::string encode(ByteArray const &b);
+        std::string encode(unsigned char *data, size_t length);
+        template <typename T>
+        std::string encode(T x)
+        {
+            return encode(x.data(), x.size());
+        }
 
-        private:
-            static bool is_base64(unsigned char c);
-            static const std::string b64chars;
-    };
+        bool is_base64(unsigned char c);
+    }
 }
 
 #endif
